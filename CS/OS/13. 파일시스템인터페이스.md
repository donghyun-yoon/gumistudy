[파일](#파일)
[접근 방법](#접근-방법)
[디렉토리 구조](#디렉토리-구조)
[보호](#보호)
[메모리 사상파일(Memory-mapped file)](#메모리-사상-파일memory-mapped-file)
[Reference](#reference)

## 파일 시스템 인터페이스

### 파일

- 일관되고 논리적인 저장 단위, 관련된 정보들의 집합에 이름을 부여한 것

  1. 프로그램: 원시 프로그램, 목적 프로그램
  2. 데이터: 문자, 숫자 등으로 구성 → 비트, 바이트, 행, 레코드들의 연속체

- 모든 파일 정보는 보조기억장치에 상주하는 디렉토리 구조에 유지됨

- **디렉토리**

  파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일

- **파티션**

  하나의 물리적 디스크 안에 여러 파티션을 두고 파일 시스템을 깔거나 스와핑등 다른 용도로 사용가능

- 파일 시스템의 **마운팅**

  파일 시스템이 여러개가 있을 때, 하나의 파일 시스템에서 다른 파티션에 있는 파일 시스템의 파일에 접근하려고 한다면 **Mounting**을 이용합니다.

  마운팅은 운영체제에게 마운트하려는 파일 시스템을 **저장하고 있는 장치의 이름**을 넘겨주고, 이것을 현재 파일 시스템에서 **어디에 둘 것인지** 알려주면 됩니다.
  
![image](https://user-images.githubusercontent.com/40350280/126901191-de2cf1df-d2f8-46a1-837f-e1d0e467c233.png)


### 접근 방법

![파일Open및Access개념도](https://user-images.githubusercontent.com/40350280/126901202-0a9d8dfa-18ee-4b2a-b12e-4b5e8e51f068.png)


1. 순차 접근(Sequential Access) ← 테이프 모델 기반

   데이터 a,b,c가 있을 때, 현재 위치 a에서 c로 접근하려면 b를 꼭 거쳐야하는 구조

2. 직접 접근(Direct Access) ← 디스크 모델 기반

   데이터 a,b,c가 있을 때, 현재 위치 a에서 c로 접근하려면 바로 건너뛰어 접근할 수 있는 구조

3. 색인 접근(Index Access) ← 직접 접근 기반

   - 각 파일마다 색인을 두는 방법: 색인 탐색 후 포인터에 의한 직접 접근
   - 색인 파일에 대한 색인 파일을 만드는 방법

### 디렉토리 구조

1. 1단계 디렉토리

   모든 파일이 같은 디렉토리에 있어 유지 및 이해가 용이

   디렉토리 내의 모든 파일의 이름이 구별되어야함

  ![1단계디렉터리](https://user-images.githubusercontent.com/40350280/126901213-86a9c677-8a6c-47ff-87a4-594fcf7a8fcd.png)


2. 2단계 디렉토리

   각 사용자마다 별도의 사용자 파일 디렉토리(User File Directory; UFD)가 배정됨

   업무의 시작이나 등록 시 마스터 파일 디렉토리(Master File Directory; MFD)를 먼저 탐색

   서로 다른 사용자 간의 파일명 혼란 해결

   사용자간의 독립성이 커져 협력이 어려워짐

   ![2단계디렉터리](https://user-images.githubusercontent.com/40350280/126901223-f909ba15-a7d0-4a0b-b374-a79e0d025970.png)


3. 트리 구조 디렉토리

   사용자들이 자신의 종속 디렉토리를 생성, 파일(0)과 디렉토리(1)를 비트를 통해 구분함

   ![트리구조디렉터리](https://user-images.githubusercontent.com/40350280/126901232-48a827a0-a3a8-4035-b205-b96932c4bab3.png)


4. 비순환 그래프 디렉토리

   디렉토리들이 종속 디렉토리나 파일을 공유할 수 있도록 허용하는 구조

   - 문제점

     동일한 파일이 서로 다른 경로에 의해 참조되는 중복 참조

     - 삭제된 공유 파일 공간의 재사용 시점 결정 문제

5. 일반적인 그래프 디렉토리 - 순환 가능 구조

   - 문제점

     탐색 시: 무한 순환 가능

     삭제 시

     참조 카운트가 0이 아닌 경우에도 삭제되어야 하는 경우 ⇒ Garbage Collection로 해결

     Garbage Collection: 접근 가능 파일을 표시한 뒤, 표시 안된 파일들을 사용 가능 기억 장소의 리스트에 추가 → 처리 시간이 많이 소모됨

### 보호

- 물리적인 손상으로부터의 보호 [신뢰도]: **복사**에 의해 해결

  하드웨어적 손상: 판독이나 기록 상의 오류, 전원 자아애, 헤드 파손, 먼지, 온도, 고의적 파괴

  소프트웨어적 손상: 파일 시스템 버그

- 부적격한 접근으로부터의 보호 [보안]: **접근 제어**로 해결

  - 접근 제어
    - 제어되는 명령
    - 사용자의 신원에 따라 접근을 허용하는 방법
    - UNIX (Grouping)

- 다른 보호 방법

  암호에 의해 파일, 디렉토리 접근 제어

  파일의 이름을 알고 있는 경우에만 접근할 수 있게 하는 방법

### 메모리 사상 파일 (Memory-mapped file)

**메모리 사상**이라고 불리는 이 접근 방식은 프로세스의 **가상 주소 공간 중 일부를 관련된 파일에 할애**하는 것을 말한다.

![다운로드](https://user-images.githubusercontent.com/40350280/126901277-1ee5b7b0-a497-446b-b134-4a207643e439.png)


메모리 사상 파일 입출력은 하나의 디스크 블록을 하나의 메모리 페이지로 사상할 수 있게 하여 파일 입출력을 메모리 접근 루틴처럼 처리한다.

1. 처음 접근은 일반적인 요구 페이징에 따라 페이지 부재를 발생시킨다.
2. 파일 내용 중 페이지크기만큼의 해당 부분이 파일시스템으로부터 물리 페이지로 읽혀 들어온다.
3. 이후의 읽기, 쓰기는 다른 메모리 접근과 동일하다.

`read()`, `write()` 시스템 호출을 사용하는 대신 메모리를 이용하여 파일 입출력을 수행함으로써 파일 접근을 단순화한다.

다수 프로세스들이 동일한 파일을 사상하여 공유할 수 있게 된다 → 공유 메모리처럼 사용 가능

## Reference

- [메모리 사상파일](https://ko.wikipedia.org/wiki/메모리-맵-파일)
- [파일시스템 인터페이스](https://mydaum00.tistory.com/entry/10-파일-시스템-인터페이스File-System-Interface)
- [디렉토리 구조 그림](https://frontalnh.github.io/2018/04/23/운영체제-파일-시스템-인터페이스/)
- [연습문제](https://ogu45.com/zbxe/school/24038)

