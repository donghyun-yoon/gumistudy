# 파일 시스템 구조

- [파일 시스템 구조](#파일-시스템-구조)
  - [1. 파일 시스템 구조(File System Structure)](#1-파일-시스템-구조file-system-structure)
  - [2. 파일 시스템 구현(File System Implementation)](#2-파일-시스템-구현file-system-implementation)
    - [2-1. 디스크상의 구조](#2-1-디스크상의-구조)
    - [2-2. 새로운 파일 생성 방법](#2-2-새로운-파일-생성-방법)
    - [2-3. 가상 파일 시스템(Virtual File System)](#2-3-가상-파일-시스템virtual-file-system)
  - [3. 디렉토리 구현 (Directory Implementation)](#3-디렉토리-구현-directory-implementation)
  - [4. 파일 할당 방법 (Allocation Method)](#4-파일-할당-방법-allocation-method)
    - [4-1. 연속 할당 (Contiguous Allocation)](#4-1-연속-할당-contiguous-allocation)
    - [4-2. 연결 할당 (Linked Allocation)](#4-2-연결-할당-linked-allocation)
    - [4-3. 파일 할당 테이블(File Allocation Table)](#4-3-파일-할당-테이블file-allocation-table)
    - [4-4. 색인 할당(Indexed Allocation)](#4-4-색인-할당indexed-allocation)
  - [5. 가용 공간의 관리(Free-Space Management)](#5-가용-공간의-관리free-space-management)
    - [5-1. 비트 벡터(Bit Vector)](#5-1-비트-벡터bit-vector)
    - [5-2. 연결 리스트 (Linked List)](#5-2-연결-리스트-linked-list)
    - [5-3. 그룹핑(Grouping)](#5-3-그룹핑grouping)
    - [5-4. 계수 (Counting)](#5-4-계수-counting)
  - [6. 효율과 성능](#6-효율과-성능)
    - [6-1. 페이지 캐시](#6-1-페이지-캐시)
  - [7. 복구](#7-복구)

<hr/>

## 1. 파일 시스템 구조(File System Structure)

<br/>

파일 시스템을 유지하기 위한 보조저장장치로 디스크가 주로 사용된다.
1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.

파일 시스템은 쉽게 데이터를 저장하고, 찾고 인출할 수 있게 함으로써 디스크를 보다 효율적이고 편리하게 사용할 수 있게 도와준다.

- 파일 시스템이 사용자에게 어떻게 보여야 할지 정의해야한다.
  - 파일 속성, 디렉토리 구조 등..
- 물리적 보조기억 장치에 놀리적 파일 시스템을 사상시키기 위한 알고리즘과 자료구조 정의가 필요하다.
- 파일 제어 블록(FCB)
  - 파일에 대한 정보를 구성하는 저장 구조
  - 파일 구조
    - 논리적 저장 단위
    - 관련 정보의 집합
- 계층적 구조 사용

    ![](https://media.vlpt.us/images/hoyeon94/post/355ef78f-2b89-4015-8c01-524f71cc2758/Untitled%204.png) 

1. I/O control
   - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져 있어서 메모리와 디스크시스템 간의 정보 전송을 담당
   - 수행 동작이 무엇인지 동작하는 장치의 위치를 제어기에 알려줌
2. basic file system
   - 적절한 장치 드라이버에게 저장장치상의 블록을 읽고 쓰도록 일반적인 명령을 내린다.
   - 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.
3. file-organization module
   - 파일과 상응하는 논리블록을 알고 있으며, 어느 디스크 공간이 비어있는지를 파악한다.
   - 파일의 논리 블록 주소를 물리 주소로 변환
4. logical file system
   - 메타데이터 정보를 관리한다.
   - 메타데이터는 파일의 내용 자체인 데이터를 제외한 모든 파일 시스템 구조를 말한다.
   - 디렉토리 구조 사용, 보호/보안 문제

<br/>
<br/>

## 2. 파일 시스템 구현(File System Implementation)

<br/>

운영체제는 파일에 접근을 요구하는 프로세스를 위해 open(), close() 시스템 호출을 구현하며 디스크와 메모리 상에 존재하는 여러 구조가 파일 시스템을 구현하는데 사용된다.

<br/>

### 2-1. 디스크상의 구조

- 부트 제어 블록(boot control block) : 볼륨 당 하나씩 존재하며 시스템이 그 파티션으로부터 운영체제를 부트 시키는 데 필요한 정보를 가지고 있다. 디스크가 운영체제를 가지고 있지 않다면 부트 제어 블록은 비어 있다. 부트 제어 블록은 일반적으로 한 파티션의 첫 번째 블록이다. UFS에서는 부트 블록, NTFS에서는 파티션 부트 섹터라 불린다.
- 볼륨 제어 블록 (volume control block) : 볼륨 당 존재하여 볼륨(파티션)의 블록의 수, 블록의 크기, 자유 블록의 수와 포인터, 자유 FCB와 포인터 같은 파티션 정보를 포함 한다. UFS에서는 수퍼블록, NTFS에서는 마스터 파일 테이블에 정보가 저장된다.
- 디렉토리 구조는 파일을 조직화 하는데 사용된다. UFS에서는 디렉토리 구조에 파일 이름 및 해당 inode 번호가 저장된다. NTFS에서는 마스터 파일 테이블에 이러한 정보가 저장된다.
- FCB는 파일 허가, 소유, 크기, 자료 블록의 위치 등을 포함하여 자세한 파일 정보를 가지고 있다. UFS에서 이는 inode라 불린다. NTFS에서 이 정보는 실제적으로 마스터 파일 테이블 안에 저장되며 파일마다 한 행을 가지고 관계 데이터베이스 구조를 사용한다.
  
    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6Gfwk%2Fbtq65e6h3co%2FK3NLoywk9aWTwtAZZ6hsAk%2Fimg.png)
      -FCB 블록 구조-

<br/>

### 2-2. 새로운 파일 생성 방법

새로운 파일이 생성되면 입출력을 위해 사용될 수 있다. 이를 위해선 우선 파일이 오픈되어야 하는데 open() 함수는 논리적 파일 시스템에 파일 이름을 넘겨준다. 이 때 오픈 되어 있는 파일인지 확인한 뒤 오픈되어 있지 않다면, 주어진 파일 이름을 찾으면 FCB가 메모리내의 테이블에 복사된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fo1tWg%2Fbtq67NzTY4q%2FQp0GnTYpkrUWSJxNPqJNpK%2Fimg.png)

open() 함수는 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터(파일 디스크립터)를 돌려준다. 
이후에 모든 파일 연산은 이 포인터를 이용하여 실행된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcfTY5D%2Fbtq7bh1ytmO%2FRraTeGofN33TEE3jV2NzzK%2Fimg.png)

오픈했던 파일을 닫으면 디스크 기반 디렉토리 구조에 업데이트 된 파일 정보가 복사된다.

<br/>

### 2-3. 가상 파일 시스템(Virtual File System)

기본적인 파일 시스템 구현의 계층은 각자 역할이 나눠져 있다.
첫 번째 계층은 열기, 읽기, 쓰기, 닫기 호출과 파일 디스크립터에 기반을 둔 파일 시스템 인터페이스
두 번째 계층이 VFS이고 다른 형태의 파일 시스템을 마운트 할 수 있게 해주고 vnode 구조를 통해 네트워크 파일 시스템 지원

- 가상 파일 시스템은 여러 유형의 파일 시스템을 지원하기 위해 객체 지향 기법을 사용
- VFS 인터페이스를 명확하게 정의하며 파일 시스템의 일반적 연산을 구현과 분리
- 전체 네트워크에 걸쳐 파일을 유일하게 표시할 수 있는 기법 제공

![](https://t1.daumcdn.net/cfile/tistory/255C844356CBFC8A2F)

<br/>
<br/>

## 3. 디렉토리 구현 (Directory Implementation)

<br/>

1. 선형 리스트
  - 파일 이름을 가진 선형 리스트(데이터 블록에 대한 포인터 포함)
  - 프로그램 용이
  - 실행하는 데 시간이 걸림
2. 해시 테이블
  - 해시 자료 구조를 가진 선형 리스트
  - 디렉토리 탐색 시간 감소
  - 충돌(collisions) 발생 가능
  - 고정 크기

<br/>
<br/>

## 4. 파일 할당 방법 (Allocation Method)

<br/>

파일을 디스크에 어떻게 배치 할 것인가?

<br/>

### 4-1. 연속 할당 (Contiguous Allocation)

각 파일이 저장장치 내에서 연속적인 공간을 차지하도록 요구한다. 
 - 대부분의 경우에서 좋은 성능을 보인다.
 - 간단하다 : 시작 지점과 길이만 필요하다.
 - 파일을 지우고 쓰는 과정에서 단편화 문제가 생길 수 있다.
 - Ex) 아주 큰 공간을 예약한 후, 파일이 장기간에 걸쳐서 서서히 커질 때는 많은 공간이 내부 단편으로 낭비된다.
 - 어느 정도의 연속된 공간만 초기에 제공하고 추후 n개의 연속된 공간을 단위로 할당하는 방식으로 해결한다.


![](https://t1.daumcdn.net/cfile/tistory/2352683A55A73EC72A)

<br/>

### 4-2. 연결 할당 (Linked Allocation)

파일을 저장장치 블록의 연결리스트 형태로 저장
- 탐색이 필요없다는 장점이 있음
- 신뢰성 문제가 생길 수 있다.(하나의 포인터를 잃는 경우)
- 포인터들을 저장한 공간이 필요함 
  - 블록을 모아 클러스터라고 하는 단위로 만들고 블록이 아닌 클러스터를 할당.

![](https://t1.daumcdn.net/cfile/tistory/273AA03A55A73EC833)

<br/>

### 4-3. 파일 할당 테이블(File Allocation Table)

연결 할당의 변형으로 FAT을 사용하는 것이다.
각 파티션의 시작 부분이 FAT으로 사용됨. 이 FAT테이블은 각 블록마다 한 개의 항목을 가지고 있고, 이 항목은 디스크 블록 번호를 인덱스로 찾는다.
이 블록 번호를 가지고 FAT테이블로 가면 그 항목은 다음 블록의 블록 번호를 가리킨다.

![](https://t1.daumcdn.net/cfile/tistory/2724DA4355A73EC932)

<br/>

### 4-4. 색인 할당(Indexed Allocation)

<br/>

각 파일은 저장장치 블록 주소를 모아놓은 배열인 색인 블록을 가진다.
이를 위해 인덱스 테이블이 필요함.
직접 접근이 가능하고 외부 단편화 문제가 발생하지 않는다.
색인 블록이 충분히 크지 않아 포인터들을 저장할 수 없다면, 다중 수준 색인을 사용한다.

![](https://t1.daumcdn.net/cfile/tistory/263FF43855A73ECA0C)

색인 블록에 대한 메모리 낭비가 있어 이러한 문제점을 보완하는 기법은 다음과 같다.
1. 연결 기법 - 색인 블록들을 연결
2. 다중 단계 색인 - 여러 단계의 직/간접 색인 블록 사용
3. 결합 기법 - 직접/단일 간접/ 이중 간접/ 삼중 간접 블록 등 다양한 색인 블록 사용

<br/>
<br/>

## 5. 가용 공간의 관리(Free-Space Management)

<br/>

디스크의 공간은 제한되어 있기 때문에 삭제된 파일들일 차지하던 공간을 새로운 파일들을 위하여 다시 재사용하여야 한다. 시스템은 이러한 자유 공간을 리스트로 유지하고 관리한다.

디스크는 자유 공간 리스트에 디스크의 모든 자유 블록들을 등록 한다. 새로운 파일을 만들려면 자유 공간 리스트를 탐색하여 새로운 파일을 위한 공간을 할당 받아야 한다. 할당 된 공간은 자유 리스트로부터 삭제 된다.

자유 공간 관리를 위해서 꼭 리스트 형태로만 구현될 필요는 없다. 관리를 위해 사용되는 다양한 방법을 알아 보자.

<br/>

### 5-1. 비트 벡터(Bit Vector)

<br/>

각 블록은 1비트로 표현된다.
블록이 자유로우면 1, 할당 되어있다면 0

예를 들어 디스크의 블록들 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 17, 18, 25, 26, 27이 비어 있고 나머지 블록은 할당되어 있다고 가정 할 때 그 자유 공간 비트맵은 다음과 같다.

> 001111001111110001100000011100000…

이 방법은 첫 번째 자유 블록 또는 n개의 연속된 자유 블록들을 찾는 일이 간편하고 효율적이다.

블록 번호 계산
> (워드의 비트 수) * (값이 0인 워드 수) + 첫 번째 1비트의 오프셋

비트 벡터는 그 전체가 주 메모리 내에 존재하지 않으면 비효율적이다.

<br/>

### 5-2. 연결 리스트 (Linked List)

<br/>

모든 자유 디스크 블록들을 함께 연결시키는 것인데 첫 번째 자유 블록은 다음 자유 블록을 가리키는 포인터를 가진다. 두 번째 자유 블록은 다음 자유 블록의 포인터를 가지고 계속 그런 방법으로 구현 된다.

![](https://t1.daumcdn.net/cfile/tistory/26490D4455A73EED3B)


<br/>

### 5-3. 그룹핑(Grouping)

<br/>

자유 리스트 방식의 변형으로 첫 번째 자유 블록 내에 n 개의 블록 주소를 저장하는 방법이다. 이 중 처음 n -1 개는 실제로 비어 있는 블록의 주소이다. 그러나 마지막 1개는 자신과 마찬가지로 n-1 개의 빈 블록 주소를 가지고 있는 자유 블록을 가리킨다.

이 방법은 연결 리스트 방법과는 달리 다수 개의 자유 블록 주소들을 쉽게 찾을 수 있다는 점이 장점이다.

<br/>

### 5-4. 계수 (Counting)

<br/>

프로그램들이 매우 자주(여러 연속된) 블록들을 할당하고(여러 연속된) 블록들을 반환 한다는 사실에 착안한 것으로 특히 연속 할당 알고리즘이나 클러스터링을 통해 공간을 할당 할 경우 유용하다.

모든 블록을 일일이 추적할 필요가 없이 연속된 자유 블록의 첫 번째 블록의 주소와 연속된 블록의 계수(count)만 유지하면 보다 효율적이다. 따라서 자유 공간 리스트의 각 항은 하나의 디스크 주소와 블록의 개수로 구성 된다.

<br/>
<br/>

## 6. 효율과 성능

<br/>

효율이 의존하는 것
- 디스크 할당과 디렉토리 알고리즘
- 파일의 디렉토리 항목에 유지되는 데이터 종류
  
성능
- 디스크 캐시 - 자주 사용되는 블로을 위한 주 메모리의 분리된 부분
- free-behind 와 read-ahead-순차 접근을 최적화 하는 기법들
- 메모리의 일부분을 가상 디스크 또는 RAM 디스크로 전용함으로써 PC 성능 개선
  
   ![](https://player.slidesplayer.org/96/16419612/slides/slide_22.jpg)

<br/>

### 6-1. 페이지 캐시

<br/>

- 페이지 캐시는 가상 메모리 기법을 사용하여 디스크 블록 대신 페이지를 캐시
- 파일 시스템을 통한 I/O 루틴은 버퍼(디스크) 캐시 사용
- 통합 버퍼 캐시가 없는 경우 이중 캐싱 발생
  - 메모리 낭비
  - 상당한 CPU 와 I/O 사이클 소비

  ![](https://player.slidesplayer.org/96/16419612/slides/slide_24.jpg)



<br/>
<br/>

## 7. 복구

<br/>

- 일관성 점검(Consistency checking)
  - 디렉토리 구조의 데이터와 디스크 상의 데이터 블록 간 비교한 후, 비일관성 수정

- 백업과 복구
  - 디스크로부터 다른 저장 장치로 부터 데이터를 주기적으로 백업하는 시스템 프로그램 사용
  - 백업으로부터 데이터를 복구함으로써 잃어버린 파일 또는 디스크 복구

<br/>
<hr/>

참고자료
- https://drawdeveloper.tistory.com/28
- https://brightmango.tistory.com/255
- https://slidesplayer.org/slide/16419612/
- https://sungwookkang.com/203?category=618942