# 2. 운영체제 구조 (Operating System Structures)
- [2.1 운영체제 서비스](#21-운영체제-서비스)
- [2.2 사용자와 운영체제 인터페이스](#22-사용자와-운영체제-인터페이스)
- [2.3 시스템 콜](#23-시스템-콜)
- [2.4 시스템 서비스](#24-시스템-서비스)
- [2.5 링커와 로더](#25-링커와-로더)
- [2.6 응용 프로그램이 운영체제마다 다른 이유](#26-응용-프로그램이-운영체제마다-다른-이유)
- [2.7 운영체제 설계 및 구현](#27-운영체제-설계-및-구현)
- [2.8 운영체제 구조](#28-운영체제-구조)
- [2.9 운영체제 빌딩과 부팅](#29-운영체제-빌딩과-부팅)

## 2.1 운영체제 서비스

운영체제는 프로그램 실행 환경을 제공한다. 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다.

다양한 운영체제 서비스에 대한 계층적 관점과 그들의 상호관계

![os2-1](https://t1.daumcdn.net/cfile/tistory/2258A235535CCABD04)

▶ 운영체제가 제공하는 서비스

- **사용자 인터페이스(user interface)**
  <br>거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다. 이 인터페이스는 여러 형태로 제공될 수 있으며 대표적으로 **Graphic User Interface(GUI), TouchScreen Interface, Command Line Interface** 등이 있다.

- **프로그램 수행(program execution)**
  <br>시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다.

- **입출력 연산(I/O operation)**
  <br>수행 중인 프로그램은 입출력을 요구할 수 있다. 이러한 입출력에는 파일 혹은, 입출력 장치가 연관될 수 있다.

- **파일 시스템 조작(file system manipulation)**
  <br>프로그램은 파일을 읽고 쓸 필요가 있고, 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 한다.

- **통신(communication)**
  <br>프로세스 사이에 정보 교환(IPC)을 지원해 준다. (Shared Memory, Message-Passing)

- **오류 탐지(error detection)**
  <br>운영체제는 모든 가능한 오류를 항상 의식하고 탐지해야 한다.

- **자원 할당(resource allocation)**
  <br>다수의 프로세스나 다수의 작업이 동시에 실행될때, 그들 각각에 자원을 할당해 주어야 한다.

- **기록 작성(logging)**
  <br>어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지에 대해서 기록 작성

- **보호(protection)와 보안(security)**
  <br>보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장, 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록



## 2.2 사용자와 운영체제 인터페이스

- **명령 인터프리터 (Command Interpreter, CLI(Command Line Interface))**<br>
  사용자의 운영체제 사이의 인터페이스로써 사용자로 부터 명령을 입력받아 해당 명령을 처리한다. 이러한 명령어 해석기를 **쉘(shell)**이라 부르며 리눅스의 Bash Shell, C Shell, Korn Shell 등이 이에 속한다.  명령어 해석기의 중요한 기능은 사용자가 입력한 명령을 시스템에서 가져와 그것을 실행하는 것이다.

- **그래픽 기반 사용자 인터페이스 (Graphical User Interface)**<br>
  그래픽 기반 사용자 인터페이스란 CLI를 통하여 사용자가 직접 명령어를 입력하는 것이 아니라 데스크톱이라고 특정지어지는 마우스를 기반으로 하는 윈도우 메뉴 시스템을 사용한다.

- **터치스크린 인터페이스 (Touch Screen Interface)**<br>
  대부분의 모바일 시스템에는 명령 라인 인터페이스나 마우스 및 키보드 시스템이 실용적이지 않기 떄문에 스마트폰 및 휴대용 태블릿 컴퓨터는 일반적으로 터치스크린 인터페이스(TouchScreen Interface)를 사용한다.



## 2.3 시스템 콜
**운영체제에 의해 사용 가능한 서비스에 대한 인터페이스 제공**<br>
커널 영역의 기능을 사용자 모드에서 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근하여 필요한 기능을 사용할 수 있게 해줌

### 1. 응용 프로그래밍 인터페이스 (Application Programming Interface, API)
어떤 기능을 사용하기 위한 함수, 프로토타입 등을 모아둔 것

가장 흔한 3가지 API
1. Windows API
2. POSIX API
3. Java API

통상 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다.

![API](https://imbf.github.io/assets/computer-science/operating-system-structures-2.png)

시스템 콜 호출을 위해서는 운영체제에 매개변수를 전달해야만 한다. 이를 위해서 보통 운영체제는 3개의 일반적인 방법을 사용한다.

▶ 시스템 콜을 위해 OS에 매개변수를 전달하는 방법 3가지
- 매개변수를 레지스터 내에 전달하는 방법
- 매개변수를 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소가 레지스터 내에 매개변수로 전달되는 방법
- 매개변수를 메모리 내의 스택에 push && pop 하는 방법

▶ 시스템 호출과 함수 호출의 차이점
- 시스템 호출 : User Mode에서 호출을 해 Kernel Mode로 가서 return값을 받아옴
- 함수 호출 : User Mode 내에 있는 기능을 호출해서 반환


### 2. 시스템 콜의 유형
  - **프로세스 제어 (Prcess Control)**
    + 끝내기(end), 중지(abort)
    + 적재(load), 실행(execute)
    + 프로세스 생성(create process)
    + 프로세스 속성 획득과 설정(get process attribute and set process attribute)
    + 시간 대기(wait time)
    + 사건 대기(wait event)
    + 사건을 알림(signal event)
    + 메모리 할당 및 해제 : malloc, free
  - **파일 관리 (File Management)**
    + 파일 생성(create file), 파일 삭제(delete file)
    + 열기(open), 닫기(close)
    + 읽기(read), 쓰기(write), 위치 변경(reposition)
    + 파일 속성 획득 및 설정(get file attribute and set file attribute)
  - **장치 관리 (Device Management)**
    + 장치를 요구(request devices), 장치를 방출release device)
    + 읽기, 쓰기, 위치 변경
    + 장치 속성 획득, 장치 속성 설정
    + 장치의 논리적 부착(attach) 또는 분리(detach)
  - **정보 유지 관리 (Information Maintenance)**
    + 시간과 날짜의 설정과 획득(time)
    + 시스템 데이터의 설정과 획득(date)
    + 프로세스 파일, 장치 속성의 획득 및 설정
  - **통신 (Communications)**
    + 통신 연결의 생성, 제거
    + 메시지의 송신, 수신
    + 상태 정보 전달
    + 원격 장치의 부착 및 분리
  - **보호 (Protection)**


## 2.4 시스템 서비스

**시스템 유틸리티. 프로그램 개발과 실행을 위해 보다 편리한 환경을 제공** <br>
이 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 반면에 나머지는 훨씬 더 복잡하다.

- **파일 관리** : 파일과 디렉터리를 생성, 삭제, 복사, rename, 인쇄, 열거할 수 있는 서비스
- **상태 정보** : 시스템의 날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수, 로깅 및 디버깅 정보 등의 상태 정보를 제공하는 서비스
- **파일 변경** : 파일의 내용을 생성하고 변경하기 위한 서비스
- **프로그래밍 언어 지원** : 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 인터프리터가 운영체제와 함께 제공되는 서비스
- **프로그램 적재와 수행** : 프로그램이 어셈블되거나 컴파일된 후, 그것이 수행하기 앞서 메모리에 적재시키는 서비스
- **통신** : 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공하는 서비스
- **백그라운드 서비스** : 네트워크 디먼, 프로세스 스케줄러 등과 같은 백그라운드 서비스


## 2.5 링커와 로더

### 링커 (Linker)
언어 번역프로그램이 생성한 목적 프로그램들과 라이브러리, 또 다른 실행 프로그램(로드 모듈) 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어

### 로더 (Loader)
컴퓨터 내부로 정보를 들여오거나 로드 모듈을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어

![linkerloader](https://imbf.github.io/assets/computer-science/operating-system-structures-4.png)

1. 소스 파일은 오브젝트 파일로 컴파일 됨
2. 링커가 이런 오브젝트 파일을 하나의 이진 실행 파일로 결합 (다른 오브젝트 파일 or 라이브러리 포함 가능)
3. 로더는 이진 실행 파일을 메모리에 적재하고, 실행 파일이 CPU 코어에서 실행 가능한 상태가 됨


## 2.6 응용 프로그램이 운영체제마다 다른 이유
각 운영체제는 고유한 System Call 집합을 제공하기 때문에 기본적으로 한 OS에서 컴파일된 응용 프로그램은 다른 OS에서 실행할 수 없다.

**여러 운영체제에서 실행 가능한 응용 프로그램 만드는 방법 3가지**

1. [Interpreter언어](https://ithub.tistory.com/86)로 작성 (JS, HTML, Python, SQL, ruby 등..)

2. 가상언어 또는 API를 사용 ([POSIX API](https://chonii.tistory.com/16))



## 2.7 운영체제 설계 및 구현

### **1. 설계 목표 (Design Goals)**<br>
  ▶ OS 설계, 구현에는 정답이 없고 입증된 권장 방법만 있다.<br>
  ▶ 하드웨어와 시스템 타입에 영향을 받는다.

  **!! 시스템 설계 시 첫번째 문제점은 시스템의 목표와 명세를 정의하는 것 !!**

  OS 설계의 요구 조건은 **사용자 목적**과 **시스템 목적**으로 분류 가능
  - 사용자 목적 : 편리, 쉽게 배움, 신뢰, 안전, 신속
  - 시스템 목적 : 유지 보수 쉬움, 적응성, 신뢰성, 효율성, 오류 없음

  => 운영체제의 명세와 설계에서 문제 해결을 위한 해법은 없다. 대신 OS 설계에 적용 가능한 일반적인 원칙들이 존재한다.


### **2. 메커니즘과 정책 (Mechanisms and Policies)**
  한 가지 중요한 원칙은 **메커니즘(Mechanism)**으로부터 **정책(Policy)**를 분리하는 것 !!

  - 메커니즘(Mechanism) : **How**, 어떻게 할 것인지 결정하는 것
  - 정책(Policy) : **What**, 무엇을 할 것인지 결정하는 것
  
  정책과 메커니즘의 분리는 융통성을 위해 매우 중요. 정책은 장소가 바뀌거나 시간의 흐름에 따라 변경될 수 있다. 정책의 변경에 민감하지 않은 메커니즘을 사용하면 개발자의 입장에서 유지 및 보수가 더욱 쉬워질 것이 명확하기 때문에 중요하다.

### **3. 구현 (Implementation)**
  다양한 언어 사용하여 구현
  
  (초기) 어셈블리어 <br>
  (오늘날) C, C++과 같은 고급 언어

  고급 언어는 다른 기종으로 이식할 때 용이하지만, 속도가 느리고 저장장치가 많이 소요 (오늘날에는 큰 문제는 아님) <br>
  좋은 자료구조와 알고리즘이 OS 주요 성능을 결정지을 가능성이 크다.


## 2.8 운영체제 구조

### **1. 모놀리식 구조 (Monolithic Structure)**
커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것<br>
UNIX 최초 형태가 이런 구조..

![Monolithic](https://imbf.github.io/assets/computer-science/operating-system-structures-5.png)

장점
- 성능 우수 (오버헤드가 거의 없고, 커널 안에서의 통신 속도가 빠름)

단점
- 구현과 유지보수가 어려움

<br>

### **2. 계층적 접근 (Layered Approach)**
계층 구조에서는 비슷한 기능을 수행하는 요소를 그룹화 하여 계층적으로 구성<br>
각 계층은 서로 인접한 계층과 상호작용하며, 각 계층은 자신의 하위 계층으로만 서비스 함

![Layered](https://imbf.github.io/assets/computer-science/operating-system-structures-6.png)

장점
- 모듈화가 잘 되어있어 계층 구조에서 시스템 검증, 오류 수정이 쉬움

단점
- 계층 구조를 정의하기 어려움
- 모든 계층이 시스템에 접근할 수 있으므로 악성코드에 민감

<br>

### **3. 마이크로커널 (MicroKernels)**
대부분의 기능을 사용자 공간에 넣고, 핵심기능만 커널이 가짐<br>
현대 OS 대부분이 이 방법을 사용 (mac os 등)

![Micro](https://imbf.github.io/assets/computer-science/operating-system-structures-7.png)

장점
- OS 확장에 용이 : 새로운 서비스들이 사용자 공간에 추가되며, 커널 변경이 필요 없음
- 서비스 대부분이 사용자 프로세스로 수행되기 때문에 보안성, 신뢰성 Good
- 모듈화 개념을 적용하였기 때문에 이식성 Good

단점
- 가중된 시스템 기능 오버헤드 때문에 속도가 느림

<br>

_!! 사실 엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않음 !!_ <br>
_!! 대신 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성 !!_


## 2.9 운영체제 빌딩과 부팅

### 운영체제 생성
1. 운영체제 소스 코드를 작성(또는 이전에 작성된 소스 코드를 확보한다.)
2. 실행될 시스템을 위해 운영체제를 구성한다.
3. 운영체제를 컴파일 한다.
4. 운영체제를 설치한다.
5. 컴퓨터와 새 운영체제를 부팅한다.

### 시스템 부트
1. 부트스트랩 프로그램(Bootstrap Program) 또는 부트 2. 로더(Boot Loader)라고 불리는 작은 코드가 커널의 위치를 찾는다.
3. 커널이 메모리에 적재되고 시작된다.
4. 커널은 하드웨어를 초기화 한다.
5. 루트 파일 시스템이 마운트 된다.

<hr>

## Reference
- https://imbf.github.io/computer-science(cs)/2020/09/03/Operating-System-Structures.html
- https://chayan-memorias.tistory.com/54