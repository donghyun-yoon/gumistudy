# 메모리 관리(Memory Management)

## 목차

[1. 개요](#1-개요)<br>

- [1-1. 메모리](#1-1-메모리)<br>
- [1-2. 메모리 계층 구조](#1-2-메모리-계층-구조)<br>
- [1-3. 메모리 단위](#1-3-메모리-단위)<br>
- [1-4. 논리 주소와 물리 주소](#1-4-논리-주소와-물리-주소)<br>
- [1-5. 주소 바인딩](#1-5-주소-바인딩)<br>
- [1-6. 동적 적재와 동적 연결](#1-6-동적-적재와-동적-연결)<br>

[2. 스와핑](#2-스와핑)<br>

[3. 연속 메모리 할당](#3-연속-메모리-할당)<br>

- [3-1. 개념](#3-1-개념)<br>
- [3-2. 고정 분할 방식](#3-2-고정-분할-방식)<br>
- [3-3. 가변 분할 방식](#3-3-가변-분할-방식)<br>

[4. 페이징](#4-페이징)<br>

- [4-1. 개념](#4-1-개념)<br>
- [4-2. 페이징의 주소 표현](#4-2-페이징의-주소-표현)<br>
- [4-3. 페이징의 특징](#4-3-페이징의-특징)<br>
- [4-4. 페이징 테이블의 구현](#4-4-페이징-테이블의-구현)<br>
- [4-5. 페이지 테이블의 구조](4-5-페이지-테이블의-구조)<br>

[5. 세그먼테이션](#5-세그먼테이션)<br>

- [5-1. 개념](#5-1-개념)<br>
- [5-2. 세그먼트 테이블](5-2-세그먼트-테이블)<br>
- [5-3. 세그먼테이션 하드웨어](5-3-세그먼테이션-하드웨어)<br>

[Reference](#reference)

<hr>

## 1. 개요

### 1-1. 메모리

메모리는 **주소**와 **데이터**로 구성되어 있다. CPU가 원하는 데이터의 주소를 메모리에 보내주게 되면 메모리는 CPU에게 해당하는 데이터를 보내준다. 또한 CPU에서 계산된 결과를 메모리의 특정 주소에 저장하고 명령을 보내면 메모리에 해당 주소에 데이터를 저장한다.

### 1-2. 메모리 계층 구조

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRsDzs%2FbtqK84Lg2rY%2FCdoEWHokgpCu11LdcVOH9K%2Fimg.png)

### 1-3. 메모리 단위

Block : **주기억장치(메인 메모리)와 보조기억장치(하드 디스크) 사이**의 데이터 전송 단위<br>
Word : **주기억장치와 레지스터 사이**의 데이터 전송 단위<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F9Plfc%2FbtqK8kt1j6l%2FjySBUyp9mlaP1KPTBH0hi0%2Fimg.png)

### 1-4. 논리 주소와 물리 주소

- 논리 메모리(Logical Memory) : 프로세스가 인지하는 정의 공간이며 프로그래머가 프로그래밍에 사용하는 공간이다. 크기는 워드의 길이에 따라 다르며 예를 들어 워드가 32bit이면 논리 메모리의 크기는 4GB가 된다.
- 물리 메모리(Physical Memory) : 하드웨어의 실제 메모리 공간으로 실제 데이터나 프로그램이 저장되는 공간인 RAM을 의미하며, 사용하는 단위는 byte이다.
- 논리 주소(Logical Address) : CPU가 생성하는 주소이며, Virtual Address라고도 한다.
- 물리 주소(Physical Address) : 메모리가 취급하게 되는 주소이다.

### 1-5. 주소 바인딩

주소 바인딩(Address Binding)이란 프로그램의 **논리 주소를 물리 주소로 매핑(mapping)** 하는 작업이다.<br>
모든 주소를 절대 주소로 바꾸며 메인 메모리의 고정된 부분에 적재하는 것을 의미한다.

### 1-6. 동적 적재와 동적 연결

- 동적 적재(Dynamic Loading) : 프로그램 실행에 반드시 필요한 루틴/데이터만 적재하는 것을 의미한다.
- 동적 연결(Dynamic Linking) : 여러 프로그램에 공통으로 사용되는 라이브러리를 관리하는 방법이다.

<hr>

## 2. 스와핑

스와핑(Swapping)이란 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 관리하는 역할을 말한다.<br>
CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치로 보내고 다른 프로세스의 메모리는 불러 들이는 것을 말한다.

![](https://t1.daumcdn.net/cfile/tistory/26647A47590433AB2D)

swap in : 메모리로 들어감(주기억장치로 불러옴)<br>
swap out : 메모리에서 나옴(보조기억장치로 내보냄)

<hr>

## 3. 연속 메모리 할당

### 3-1. 개념

연속 메모리 할당이란 각 프로세스가 필요로 하는 메모리 요구량을 미리 분석 해서 결정해 놓고 그 프로세스의 메모리를 하나의 덩어리로 설정하여 실제 메모리에 할당 해주는 원리를 말한다.<br>
크게 **고정 분할 방식**과 **가변 분할 방식**이 존재한다.

### 3-2. 고정 분할 방식

주어진 개수 만큼의 영구적인 분할로 미리 나누어 두고 각 분할에 하나의 프로그램을 적재하는 방식이다.<br>
이 분할의 크기를 모두 동일하게 할 수도 있고 서로 다르게 할 수도 있다.<br>
하나의 분할에는 하나의 프로그램만 적재 가능하므로 **외부 단편화**와 **내부 단편화**가 발생한다.

외부 단편화

- **프로그램의 크기 > 분할의 크기**인 경우 발생한다.
- 프로그램을 적재하지 못하는 빈 메모리 공간으로 사용될 수 없는 작은 분할을 의미한다.

내부 단편화

- **프로그램의 크기 < 분할의 크기**인 경우 발생한다.
- 프로그램이 분할에 적재되고 나서 분할 내부에 사용될 수 없는 메모리 조각을 의미한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc8tznE%2Fbtq2krawFHX%2Fe6waRVnKquajhynld4JX90%2Fimg.png)

### 3-3. 가변 분할 방식

메모리에 적재되어 있는 프로세스 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식이다.<br>
가변 분할 방식에서 프로세스의 크기보다 분할의 크기보다 크게 할당하기 때문에 내부 단편화는 발생하지 않는다.
하지만 이미 메모리에 존재하는 프로그램이 종료되고 메모리 크기보다 더 작은 크기의 새로운 프로세스가 할당될 때 외부 단편화가 발생할 수 있다.<br>
또한, 프로세스를 어떤 위치에 올릴지 결정하기 위한 동적 메모리 할당 문제가 있다.<br>

**기억장치 배치 전략**

- 최초 적합 방법(first-fit) : 가용 공간을 차례대로 살펴보면서 **프로그램 크기 < 가용 공간 크기**가 최초로 발견될 때, 해당 프로세스를 할당한다. 모든 가용 공간을 탐색하지 않아 시간적인 측면에서 효율적이다.
- 최적 적합 방법(best-fit) : **프로세스 크기 < 가용 공간** 크기인 가장 작은 공간을 찾고 프로세스를 할당한다. 모든 가용 공간 리스트가 크기 순으로 정렬되어 있지 않으면, 모든 가용 리스트를 탐색해야하는 오버헤드가 발생한다.
- 최악 적합 방법(worst-fit) : **프로세스 크기 < 가용 공간** 크기인 가장 큰 공간을 찾고 프로세스를 할당한다. 모든 가용 공간 리스트가 크기 순으로 정렬되어 있지 않으면, 모든 가용 리스트를 탐색해야하는 오버헤드가 발생한다.

| 영역번호 | 영역크기 | 상태   |
| -------- | -------- | ------ |
| 1        | 12K      | 공백   |
| 2        | 20K      | 공백   |
| 3        | 15K      | 사용중 |
| 4        | 17K      | 공백   |
| 5        | 30K      | 공백   |

배치 전략 중 15K 프로그램이 할당 받는 영역의 번호는 다음과 같다.

- 최초 적합 : 2번
- 최적 적합 : 4번
- 최악 적합 : 5번

### 3-4. 압축

외부 단편들을 한 곳으로 모으는 것을 **압축(compaction)** 이라 한다. 단편들을 한 곳으로 모아 사용할 수 있도록 하는 것이다. 하지만 이러한 압축은 항상 가능하지 않다. 프로세스들의 재배치가 로딩시에만 이루어진다면 압축이 불가능하다. 주소결속이 실행시간에 동적으로 이루어질 수 있는 주소체계이어야 한다. 그래야 압축과정 후에도 해당 프로세스의 재배치 레지스터 값을 수정해서 사용할 수 있게될 것이다.<br>
하지만 이러한 압축도 메모리를 이동하는 것이므로 비용이 든다. 이러한 비용을 **압축 비용** 이라고 부른다. 단편들을 한 곳으로 모으기 위해 이동되는 메모리의 양이 압축 비용인 것이다.

<hr>

## 4. 페이징

### 4-1. 개념

- 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식이다.
- 단편화가 문제가 되는 이유는 프로그램을 연속된 메모리공간에 탑재해야만 하기 때문이다. 이러한 '연속적'이라는 조건을 없어지도록 하는 것이 페이징 기법이다.
- 페이징 기법은 연속된 물리공간을 필요로 하지 않으면서도, 실행시간 및 주소결속 등 프로그램 수행에는 문제가 없도록 하는 방식이다.

페이징을 구현하는 기본적인 방법은 **물리적 메모리를 고정된 크기의 프레임(Frame)** 으로 나누고, **논리적 메모리를 동일한 크기의 페이지(Page)** 로 나누는 것이다.

페이징을 위한 하드웨어의 지원

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPWRxh%2FbtqNnwEXDoR%2FAsKvismwtWVVgHrfUMvx2K%2Fimg.png)

CPU에 의해 생성된 모든 주소들은 페이지 번호(Page Number, p)와 페이지 간격(Page Offset, d)로 나뉜다. 페이지 번호는 페이지 테이블의 인덱스로써 사용된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCjJly%2FbtqNkd0BQ7x%2F2WPjfhSwXRoZnZd8jbqS61%2Fimg.png)

### 4-2. 페이징의 주소 표현

페이징 기법에서는 실제 어떤 변수(논리 주소)가 저장되어 있는 어떤 바이트 주소(물리 주소)를 알아야 되긴 하지만 이것들이 페이지 단위의 묶음으로 배치가 되기 때문에 먼저 페이지가 어디에 있는지를 알아내야 한다. 다음에 그 안에서의 변수의 실제 바이트 위치는 페이지 안에서의 위치와 이 프레임 안에서의 위치가 일치하게 된다. 그래서 페이지가 어디에 있는가를 알아내는 것이 더 중요하다.<br>

논리 주소 공간의 크기가 2^m이고, 페이지의 크기가 2^n일 때 상위 (m-n) 비트는 페이지 번호, 하위 n 비트는 오프셋이다.

논리 주소 구조
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcZUsES%2FbtqAIEiwdEF%2FIwUsszCEdMo5VlCECgR250%2Fimg.png)

**페이지 크기가 4KB이고 메모리 크기가 256KB인 메모리 페이징 시스템이 있다.**

- 페이지는 2^12 Byte임을 알 수 있고 메모리는 2^18Byte가 됨을 알 수 있다.

**페이지 프레임 수는? (페이지 번호 수 (상위 m-n비트) )**

- 메모리 전체 크기에 페이지가 최대 몇개 들어갈 수 있는지를 묻는 것이므로 2^18/2^12 = 2^6 = 64개가 된다.

**이 메모리 주소를 해결하는 데 필요한 비트 수는?**

- 메모리 주소를 모두 표현하기 위해서는 메모리가 2^18임을 알고있고 결국 비트가 18개가 있어야 2^18을 만족 할 수 있게 된다. 따라서 18비트가 있으면 된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBAI0p%2FbtqAKvjVQkb%2FMuLxFNPPYHey5lra9ICb7K%2Fimg.png)

**페이지 번호에 사용하는 비트와 페이지 오프셋에 사용하는 비트는?**

- 페이지는 모두 64개가 있다 했다. 따라서 그림은 다음과 같아진다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2NtpS%2FbtqAJu67HmC%2FSHZhlcgx7G5MkBlK1k7giK%2Fimg.png)

### 4-3. 페이징의 특징

- 사용자 / 프로세스의 편의성 : 연속된 논리 주소 공간을 독립적으로 사용한다 -> 주소 변환은 하드웨어와 운영체제에 의해 처리된다.
- 프레임 단위의 비연속적 메모리 할당 : 동적 메모리 할당에 따른 문제가 없다 -> 외부 단편화가 없다.
- 프레임 테이블 : 프로세스마다 각각 다른 페이지 테이블을 가지고 있다. 그래서 운영체제는 실제로 어떤 프레임이 어떤 프로세스의 어떤 메모리에 할당되어있는가라는 정보를 쉽게 찾아내기위해 프레임 테이블을 관리하고 있다. 어떤 프로세스의 어떤 프레임이 사용되고 사용되지 않냐를 빠르게 확인 할 수 있다.
- 페이징과 문맥 교환 : 페이지 테이블을 재설정하기 위해 문맥 교환 시간이 증가한다. 각 프로세스마다 페이지 테이블이 있고 이 페이지테이블은 메모리에 저장이 돼 있지만 어떤 프로세스를 실행할떄 이 페이지 테이블을 사용하고, 또, 다른 프로세스일땐 다른 페이지 테이블을 사용하면서 메모리에서 다른 페이지 테이블 이미지를 가져와 재설정하게 되어 문맥 교환 시간이 생기게 된다.
- 공유 페이지 : 각각의 프로세스마다 다른 논리 메모리 공간을 가지고 있지만 그 다른 프로세스들의 특정 페이지가 실제 물리 메모리에는 같은 프레임으로 연결되도록 페이지 테이블 정보를 가지고 있게 된다면 서로 다른 프로세스이지만 동일한 메모리를 사용할 수 있다. 만약 메모리 침범 제약만 관리하게 된다면 프로세스 내에 메모리 공유가 좀 더 간단하게 이루어질 수 있다는 장점이 생기게 된다.

### 4-4. 페이징 테이블의 구현

**페이지 테이블도 메모리에 저장**

기준 레지스터 (Page-Table Base Register, PTBR)에 메모리에 저장된 페이지 테이블의 시작 주소를 저장한다. 문맥 교환 시에 페이지 테이블 교체 비용이 작다. -> PTBR값만 변경하면 된다.

**메모리 접근 시간 문제**

실질적으로 어떤 메모리에 위치한 변수에 접근하기 위해서는 먼저 이 페이지 테이블이 있는 메모리를 먼저 접근해서 페이지 테이블 데이터를 가지고 온 후 이것을 참조해서 논리 주소를 물리 주소로 변환하는 작업을 거친 후에 실제로 그 메모리에 접근하여 2번 메모리에 접근하는 상황이 발생하게 된다. 이는 페이징 성능상에 중요한 문제가 된다.

**TLB(Translation Look aside Buffer)**

위의 문제들을 해결하기 위한 방법으로 페이지 테이블을 위한 소형의 하드웨어 캐시를 TLB라고 한다.<br>
TLB는 MMU(Memory-Management Unit)의 일종으로 Virtual에서 Physical로 변환되는 값을 가지고 있는다.

**TLB의 특징**

- 접근 속도가 매우 빠른 연관 메모리(associative memory)이다.
- TLB 내의 각 항목(entry)은 키(key)와 값(value)로 구성되며 key는 페이지 번호, value는 페이지 번호에 해당하는 프레임 번호이다.
- 요청된 페이지 번호로 모든 항목을 동시에 비교 가능하며 비싼 메모리로써 보통 64 ~ 1024 항목만이 저장된다.
- 메모리 참조 시간은 주소 변환을 하지 않는 경우보다 10% 이하의 시간만 더 소요된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSX00A%2FbtqAJxbOQUC%2FBOyFAZlGPBUvU5edBvvaE1%2Fimg.jpg)

### 4-5. 페이지 테이블의 구조

실제 컴퓨터 시스템에서의 페이지 테이블은 크기가 매우 커서 페이지 테이블을 연속된 메모리 공간에 배치하기가 어려우므로 비효율적인 메모리 공간 배치가 될 수 있다.

**계층적 페이징(Hierarchical Paging)**

2단계 페이징 기법(two-level paging scheme)를 사용하여 페이지 테이블 자체가 다시 페이징 되는 것이다.

![](https://t1.daumcdn.net/cfile/tistory/993509445BC1685820)

![](https://t1.daumcdn.net/cfile/tistory/993690455BC16DC506)

위의 그림은 이 계층적 페이징 구조에 의한 주소 변환 기법을 나타내고 있다. 이 방식에서는 주소 변환이 바깥 페이지 테이블에서 시작하여 안쪽으로 들어오므로 이 방식을 전방 사상 페이지 테이블(forward-mapped page table)이라고 한다.

**해시 페이지 테이블(Hash Page Table)**

논리 주소의 페이지 번호를 해시 값으로 사용한다. 32비트 이상의 논리 주소 공간을 위한 페이지 테이블 구성방법으로 같은 위치에 해당되는 해시 페이지 테이블의 항목은 연결 리스트를 가지고 있으며 해시 원소는 세 개의 필드(가상 페이지 번호, 매핑 페이지 프레임 번호, 연결 리스트 상의 다음 포인터)를 가지고 있다.

![](https://t1.daumcdn.net/cfile/tistory/9951B2445BC174AC18)

해시 알고리즘의 순서

1. 가상 주소 공간으로부터 페이지 번호가 오면 그것을 해싱한다.
2. 해시형 페이지 테이블에서 연결 리스트를 따라가며 첫 번째 원소와 가상 페이지 번호를 비교한다.
3. 일치하면 그에 대응하는 페이지 프레임 번호(두 번째 필드)를 가져와 물리적 주소를 얻는다.
4. 일치하지 않으면 연결 리스트의 그 다음 포인터로 3의 순서를 반복한다.

**역 페이지 테이블(Inverted Page Table)**

테이블은 가상 주소에 대해 오름차순으로 정렬되어 있으며 운영체제는 이 테이블에서 원하는 페이지가 어느 곳에 있는지 계산하여 접근한다. 이러한 기법의 단점으로는 페이지 테이블의 크기이다.이러한 문제를 해결하기 위해 역 페이지 테이블(inverted page table)방법을 사용한다.

![](https://t1.daumcdn.net/cfile/tistory/998AFE455BC175EB1A)

역 페이지 테이블 구성 순서

1. 가상 주소는 pid, page-number, offset 세 가지 항목으로 구성된다.
2. 각 역 페이지 테이블의 항목은 pid, page-number의 쌍으로 이루어져 있으며 pid는 주소 공간 ID의 역할을 한다.
3. 메모리 참조가 발생하면 pid, page-number의 쌍으로 이루어진 가상 주소의 일부 메모리 서브시스템에 전달된다.
4. 역 페이지 테이블에서 일치하는 것이 있는지 검색한다.
5. 일치하는 것이 i 번째 항목에서 발견되면 물리주소는 i, offset이 되고 일치 하는 것이 없으면 잘못된 메모리로 간주한다.

장점

논리 페이지마다 항목을 가지는 대신 물리 프레임에 대응되는 항목만 테이블에 저장하기 때문에 메모리에서 훨씬 작은 공간을 점유한다.

단점

주소 변환 시간이 더 오래 걸릴 수 있으며 프레임에 따라 저장되어 있어 탐색은 비효율적이다.

<hr>

## 5. 세그먼테이션

### 5-1. 개념

여러 개의 작은 단위로 쪼갠 다음에 메모리를 할당하는 방법이다.<br>
페이징하고 다른 점은 페이징에서는 분할하는 단위가 고정된 크기의 페이지 였다면 세그멘테이션에서는 프로그램의 논리적인 단위에 따라 프로세스의 메모리 공간을 구분한다는 것이다.<br>
세그먼트의 논리 주소는 세그먼트의 이름(번호)와 오프셋으로 나뉜다.

### 5-2. 세그먼트 테이블

세그먼트 테이블에서는 각각의 세그멘트가 차지하는 크기가 서로 다르기 때문에 각 세그멘트가 실제 메모리의 어떤 위치에 저장되어 있느냐라는 정보와 함께 끝 주소 즉 크기까지 같이 포함하고 있는 정보를 가지고 있는 것이 세그멘테이션 세그먼트 테이블이라고 할 수 있다.

### 5-3. 세그먼테이션 하드웨어

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbd1Bzn%2FbtqAKur3847%2F8GEFV56KPoiUJx4wO7k1S0%2Fimg.png)

논리 주소는 세그먼트 번호와 세그먼트 안에 오프셋으로 구성되어 있다. 그리고 세그먼트 테이블에서 시작 주소와 그 세그먼트 테이블의 끝 주소를 읽어내고 끝 주소하고 내부에서 오프셋 위치를 비교를 하게 된다. 그래서 오프셋 위치는 당연히 끝 주소보다 더 작아야 된다. 만약에 더 크다면 잘못된 세그먼트를 침범한다고 할 수 있다.

<hr>

## Reference

- https://otugi.tistory.com/183
- https://jinhyy.tistory.com/33
- https://kim-hoya.tistory.com/17
- https://junyng.tistory.com/45
- https://inuplace.tistory.com/346?category=884574
- https://4legs-study.tistory.com/48
- https://goodmilktea.tistory.com/35
- https://neos518.tistory.com/125
