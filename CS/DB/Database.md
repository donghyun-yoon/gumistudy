# Database

### 무결성이란

> 데이터의 정확성, 일관성, 유효성을 유지하는 것

1. **개체 무결성**: 기본키로 선택된 필드는 빈 값을 허용하지 않는다.
2. 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다.
3. **도메인 무결성**: 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됐는지를 체크하는 것이다.
4. 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 고유한 값을 가진다. 
5. **NULL 무결성**: 특정 속성값에 NULL이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL이 될 수 없다는 제약조건
6. **키 무결성**: 한 릴레이션에는 최소한 하나의 키가 존재해야한다.

**무결성을 유지하려는 이유**: 무결성이 유지되어야 DB에 저장된 값과 현실세계의 실제 값이 일치한다고 신뢰할 수 있기 때문

### 트랜잭션

>  하나의 논리적 기능을 수행하기 위한 작업의 단위로, DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.

- 성질(**ACID**)

  **Atomicity**: 트랜잭션의 연산이 DB에 모두 반영되거나 전혀 반영이 되지 않는 두 가지의 경우 중 하나만 수행해야한다. => 원자성

  **Consistency**: 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB 상태로 변환되어야한다. => 일관성

  **Isolation**: 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랜잭션에서 수행 결과를 참조할 수 없다. => 독립성

  **Durability**: 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야한다. => 영속성

- 트랜잭션을 **병행 처리**할 때 발생할 수 있는 문제

  1. **갱신 내용 손실**: 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
  2. **현황 파악 오류**: 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
  3. **모순성**: 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
  4. **연쇄 복귀**: 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

  **병행 처리의 문제를 방지하기 위한 방법**

  - **로킹 제어 기법**을 활용한다.

    어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법이다. 종류는 크게 두가지가 있는데 공유 로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고 배타 로킹은 읽기,쓰기 둘다 불가능하게 한 것이다.

    - 로킹 단위를 크게 했을 때와 작게 했을 때의 차이점

    로킹 단위에 따라 다르지만, 트랜잭션의 직렬화 가능성이 높아진다. 데드락이 발생할 수 있다.

- **Commit**, **Rollback**

  Commit: 해당 트랜잭션으로 반영된 DB 변경사항을 저장하는 것

  Rollback: 해당 트랜잭션으로 반영된 DB 변경사항을 취소하는 것



### 정규화

> 데이터의 중복을 최소화하고 테이블의 삽입, 삭제, 갱신 과정에서 발생하는 이상현상을 방지하기 위함입니다.

1. 제 1정규화: **각 컬럼들은 값이 원자값을 가지게 바꾼다.**

2. 제 2정규화 : 테이블의 모든 컬럼에서 **부분 함수적 종속**을 제거하는 것

   부분 함수적 종속: 테이블 속성 간의 관계에 대한 제약조건 (A가 B를 결정할 때는 B는 A에 함수적으로 종속된다.)

   완전 함수적 종속: 속성들의 집합 X에 대해 Y가 함수적으로 종속될 때, X의 부분집합에 대하여 함수적으로 종속되지 않는 경우는 Y는 X에 대하여 완전 함수적 종속이라고 한다.

3. 제 3정규화 : 기본키를 제외한 속성들 간의 **이행적 함수 종속**을 없애는 것

   이행적 함수 종속: A->B, B->C가 성립할 때 A->C가 성립되는 것

4. 제 BCNF화 : 결정자이면서 후보키가 아닌 것들 제거

   ![bcnf 정규화](https://user-images.githubusercontent.com/40350280/132189945-ca86ec1a-c504-4951-9398-d11a06ec4ad9.png)

5. 제 4정규화 : 다치 종속 제거

   하나의 컬럼에 여러 값을 가지는 경우 릴레이션을 분해할 수 있다.

6. 제 5정규화 : 조인 속성 제거

   조인종속성: 릴레이션 스키마의 모든 올바른 릴레이션 상태가 분해될 때, 비부가적인 조인 분해, 무손실 분해를 가져야함

- 역정규화

  정규화를 진행할 수록 하나의 테이블을 여러 테이블로 나누게 되는데, 만약 데이터 호출 시 여러 테이블을 불러서 JOIN을 해줘야한다면 이 비용도 만만치 않기 때문에 역정규화를 한다.



### DB 장애

1. 트랜잭션 장애: 트랜잭션을 정상적으로 완료하지 못함
2. 시스템 장애: 하드웨어, 소프트웨어 고장으로 인한 장애
3. 디스크 장애: 디스크 스토리지 일부 혹은 전체 붕괴로 인한 장애

- 회복 기법

1. 로그기반 회복기법

2. 지연갱신 회복기법

   write 연산 지연, 로그에 DB변경 내역 저장

   트랜잭션 완료 시 로그를 보고 write 연산 수행

   트랜잭션 완료 시 장애 발생: REDO만 실행

   트랜잭션 미완료시 장애 발생: 로그 무시

3. 즉시 갱신 회복기법

   즉시 DB변경, 로그에 기록

   장애 발생 시 로그에 기반하여 UNDO 실행

4. 체크포인트 회복기법

   체크 포인트를 지정하여 장애 발생 시 체크 포인트까지 UNDO 실행 후 다시 REDO 실행

5. 그림자 페이징 회복기법

   하드디스크에 그림자 페이지를 만들고 저장해두고 장애 발생시 하드디스크에 있는 페이지로 주 메모리 페이지 변경, 장애 미발생 시 그림자 페이지 테이블은 삭제



### 관계형 데이터베이스, 비 관계형 데이터베이스

- 차이점

  **관계형 데이터베이스**란 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다.이처럼 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징이다.

  **비 관계형 데이터베이스**는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스이다. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징이다. 흔히들 NoSQL(not only SQL)이라고 하며 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용한다.

  ![sql,nosql](https://user-images.githubusercontent.com/40350280/132189998-a2a2ca30-a9d6-440c-856d-ed890f3ff9af.PNG)

- RDBMS와 비교하였을 때, NoSQL의 장점

  가장 큰 장점이라면 JOIN 처리가 없기 때문에 스케일 아웃을 통한 노드 확장 용이하다는 점이다. 뿐만아니라 가변적인 데이터구조로 데이터를 저장할 수 있어서 훨씬 더 유연성이 높다. 단점으로는 다양하고 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없는 것을 꼽을 수 있다.

  속도적인 측면에서는 대표적인 RDBMS인 MySQL이나 ORCLE이 워낙 최적화가 잘 되어있기도하고 주어진 상황에 따라 아주 케이스바이케이스라 뭐가 더 좋다라고는 하기 어렵다.

- 어떤 상황에서 NoSQL을 쓰는 것이 더 적합할까

  유연한 스키마를 가지고 있기 때문에 비정형 데이터를 저장해야할 때 사용하면 적합하다.



## Reference

https://kadamon.tistory.com/21

https://mangkyu.tistory.com/110

https://dingrr.com/blog/post/%EA%B0%9C%EB%B0%9C-sql-vs-nosql-%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C