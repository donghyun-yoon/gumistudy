# 서버(세션) 기반 인증 시스템 vs 토큰 기반 인증 시스템

- [1. 서버(세션) 기반 인증 시스템](#1-서버세션-기반-인증-시스템)
- [2. 토큰 기반 인증 시스템](#2-토큰-기반-인증-시스템)


## 1. 서버(세션) 기반 인증 시스템

### **서버(세션) 기반 인증 시스템이란?**

기존의 인증 시스템은 서버 기반 인증 방식으로 **서버 측에서 사용자들의 정보를 기억**하고 있어야 함. **사용자들의 정보를 기억하기 위해서는 세션을 유지**해야 하는데, 메모리나 디스크 또는 DB를 통해 관리함. 서버는 클라이언트의 요청을 받으면 그 상태를 계속 유지하여 정보를 서비스에 활용하는데, 이를 Stateful 서버라고 함. 이러한 서버 기반의 시스템은 다음과 같은 흐름을 가짐.

![session](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbe5HFu%2FbtqAsR8iEdh%2Frk9Xno6XlQAwbTWFiGIXIk%2Fimg.png)

소뮤고 시스템에서는 아직 많이 사용되고 있지만, 웹/앱 어플리케이션이 발달하게 되며 서버 확장이 어려움 등의 다음과 같은 문제점들을 보임.

|||
|---|---|
|**세션**|서버가 세션 정보를 모두 저장하게 되면 로그인한 사용자가 늘어났을 때 메모리에 부하가 걸리게 됨. 이를 피하기 위해 DB에 저장하기도 하는데, 이 또한 DB에 무리를 줄 수 있음.|
|**확장성**|사용자가 늘어나면 많은 트래픽을 처리하기 위해 세션을 분산시켜 관리하는 시스템을 설계해야 하지만, 이러한 과정은 매우 어렵고 복잡함.|
|**CORS<br>(Cross-Origin Resource Sharing)**|웹 어플리케이션에서 세션을 관리할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있음. 따라서 쿠키를 여러 도메인에서 관리하는 것이 번거로움.|

이러한 문제들 때문에 토큰 기반의 인증 시스템을 사용

## 2. 토큰 기반 인증 시스템

### **토큰 기반 인증 시스템이란?**

토큰 기반 인증 시스템은 **인증받은 사용자에게 토큰을 발급하고, 서버에 요청을 보낼 때 헤더에 토큰을 포함하도록 하여 유효성을 검사함.** 이러한 시스템에서는 더 이상 사용자의 인증 정보를 서버에 유지하지 않고 클라이언트의 요청만으로 작업 처리가 가능. 서버 기반 인증 시스템과 달리 **상태를 유지하지 않는 Stateless한 구조를 가짐.** 이러한 토큰 기반의 인증 방식을 통해 여러 문제를 해결할 수 있는데, 대표적으로 사용자의 로그인 여부를 신경쓰지 않고 손쉽게 시스템 확장이 가능.

> ▶ 토큰 기반 인증 시스템 작동 과정 예시
>
> 1. 사용자가 아이디, 비밀번호로 로그인을 함
> 2. 서버 측에서 정보를 검증
> 3. 정보가 정확하다면 사용자에게 토큰을 발급
> 4. 클라이언트 측에서 이 토큰을 저장해두고, 서버에 요청할 때 마다 토큰을 함께 전달 (Http 요청 헤더에 토큰을 포함시킴)
> 5. 서버는 토큰을 검증하고 요청에 응답.

![token](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FogoAg%2FbtqAriyT5sY%2FYYt2wkEz50kKN47mLwRDXK%2Fimg.png)

### **토큰 기반 인증 시스템의 이점**
1. **무상태성(Stateless) & 확장성(Scalability)**<br>
토큰은 클라이언트 측에 저장되기 때문에 서버는 완전히 Stateless하며, 클라이언트와 서버의 연결고리가 없기 때문에 확장하기에 매우 적합하다. 만약 사용자 정보가 서버 측 세션에 저장된 경우에 서버를 확장하여 분산처리 한다면, 해당 사용자는 처음 로그인 했었던 서버에만 요청을 받도록 설정을 해주어야 한다. 하지만 토큰을 사용한다면 어떠한 서버로 요청이 와도 상관이 없다.

2. **보안성**<br>
클라이언트가 서버로 요청을 보낼 때 더 이상 쿠키를 전달하지 않으므로, 쿠키 사용에 의한 취약점이 사라지게 된다. 하지만 토큰 환경의 취약점이 존재할 수 있으므로 이에 대비해야 한다.

3. **확장성(Extensibility)**<br>
시스템의 확장성을 의미하는 Scalability와 달리 Extensibility는 로그인 정보가 사용되는 분야의 확정을 의미한다. 토큰 기반의 인증 시스템에서는 토큰에 선택적인 권한만 부여하여 발급할 수 있으며 OAuth의 경우 Facebook, Google 등과 같은 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.

4. **여러 플랫폼 및 도메인**<br>
서버 기반 인증 시스템의 문제점 중 하나인 CORS를 해결할 수 있는데, 애플리케이션과 서비스의 규모가 커지면 여러 디바이스를 호환시키고 더 많은 종류의 서비스를 제공하게 된다. 토큰을 사용한다면 어떤 디바이스, 어떤 도메인에서도 토큰의 유효성 검사를 진행한 후에 요청을 처리할 수 있다. 이런 구조를 통해 assests 파일(Image, html, css, js 등)은 모두 CDN에서 제공하고, 서버 측에서는 API만 다루도록 설게할 수 있다.


# JWT (JSON Web Token)

- [1. JWT(Json Web Token)란?](#1-jwtjson-web-token란)
- [2. JWT 구조](#2-jwt-구조)
- [3. JWT 단점 및 고려사항](#3-jwt-단점-및-고려사항)

## 1. JWT(Json Web Token)란?

### JWT 개념
JWT(Json Web Token)란 **Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token**이다. JWT는 **토큰 자체를 정보로 사용하는 Self-Contained 방식**으로 정보를 안전하게 전달한다. 주로 회원 인증이나 정보 전달에 사용되는 JWT는 아래의 로직을 따라서 처리된다.

![jwtlogic](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrdboS%2FbtqArUrgcMr%2FHWY80zNL9reAv6FeE6AYE1%2Fimg.png)

애플리케이션이 실행될 때, JWT를 static 변수와 로컬 스토리지에 저장하게 된다. static 변수에 저장되는 이유는 HTTP 통신을 할 때마다 JWT를 HTTP 헤더에 담아서 보내야 하는데, 이를 로컬 스토리지에서 계속 불러오면 오버헤드가 발생하기 때문이다. 클라이언트에서 JWT를 포함해 요청을 보내면 서버는 허가된 JWT인지를 검사한다. 또한 로그아웃을 할 경우 로컬 스토리지에 저장된 JWT 데이터를 제거한다. (실제 서비스의 경우에는 로그아웃 시, 사용했던 토큰을 blacklist라는 DB 테이블에 넣어 해당 토큰의 접근을 막는 작업을 해주어야 한다.)

## 2. JWT 구조
JWT는 **Header, Payload, Signature**의 3 부분으로 이루어지며, Json 형태인 **각 부분은 Base64로 인코딩 되어 표현**된다. 또한 **각각의 부분을 이어 주기 위해 `.` 구분자를 사용**하여 구분한다. 

( * Base64는 암호화된 문자열이 아니고, 같은 문자열에 대해 항상 같은 인코딩 문자열을 반환)

### **1. Header**
토큰의 헤더는 **typ**과 **alg** 두 가지 정보로 구성된다. alg는 헤더(Header)를 암호화 하는 것이 아니고, **Signature를 해싱하기 위한 알고리즘을 지정**하는 것이다.

- typ: 토큰의 타입을 지정 ex) JWT
- alg: 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용 ex) HS256(SHA256) 또는 RSA

```
{
    "alg": "HS256",
    "typ": JWT
}
```

### **2. PayLoad**
토큰의 페이로드에는 **토큰에서 사용할 정보의 조각들인 클레임(Claim)**이 담겨 있다. 

클레임은 총 3가지로 나누어지며, Json(Key/Value) 형태로 다수의 정보를 넣을 수 있다.

### 2.1 등록된 클레임(Registered Claim)
등록된 클레임은 **토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터**들로, 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 하기 위해 key는 모두 길이 3의 String이다. 여기서 subject로는 unique한 값을 사용하는데, 사용자 이메일을 주로 사용한다.

- iss: 토큰 발급자(issuer)
- sub: 토큰 제목(subject)
- aud: 토큰 대상자(audience)
- exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370
- nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음
- iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음
- jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용

### 2.2 공개 클레임(Public Claim)
공개 클레임은 **사용자 정의 클레임으로, 공개용 정보를 위해 사용**된다. **충돌 방지를 위해 URI 포맷을 이용**하며, 예시는 아래와 같다.

```
{
    "https://~~~~.com": true
}
```

### 2.3 비공개 클레임(Private Claim)
비공개 클레임은 **사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장**한다. 아래의 예시와 같다.

```
{
    "token_type": access
}
```

### **3. Signature**
서명(Signature)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. 서명(Signature)은 위에서 만든 헤더(Header)와 페이로드(Payload)의 값을 각각 BASE64로 인코딩하고, 인코딩한 값을 비밀 키를 이용해 헤더(Header)에서 정의한 알고리즘으로 해싱을 하고, 이 값을 다시 BASE64로 인코딩하여 생성한다.

▶ JWT 토큰 예시

![jwtexample](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc3oKza%2FbtqArSHlIuP%2FQQU4oljS5KxyNgv4651Nk1%2Fimg.png)

생성된 토큰은 HTTP 통신을 할 때 Authorization이라는 key의 value로 사용된다. 일반적으로 value에는 Bearer이 앞에 붙여진다.

```
{
    "Authorization": "Bearer {생성된 토큰 값}"
}
```

## 3. JWT 단점 및 고려사항

- Self-contained : 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다. 
- 토큰 길이 : 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다. 
- Payload 인코딩 : 페이로드(Payload) 자체는 암호화 된 것이 아니라, BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 한다. 
- Stateless : JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 한다. 
- Tore Token : 토큰은 클라이언트 측에서 관리해야 하기 때문에, 토큰을 저장해야 한다.

<hr>

## Reference
- https://velopert.com/2350
- https://mangkyu.tistory.com/56